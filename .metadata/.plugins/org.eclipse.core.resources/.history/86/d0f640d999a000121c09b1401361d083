package edu.washington.cs.opencvtests;

import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaRecorder;
import android.util.Log;

public class AudioTest {
	private static final String TAG = "AudioTest";
	
	private static final int SAMPLE_RATE = 44100;
	private static final int CHANNEL_CONFIG = AudioFormat.CHANNEL_IN_MONO;
	private static final int AUDIO_FORMAT = AudioFormat.ENCODING_PCM_16BIT;
	private static final int PREFERRED_BUFFER_SIZE = 2048;
	
	private AudioRecord mAudioRecorder;
	
	private int mBufferSize;
	
	private short [] mBuffer;
	
	private Runnable mReadAudioDataRunnable = new Runnable() {

		@Override
		public void run() {
			while(mAudioRecorder.getRecordingState() == AudioRecord.RECORDSTATE_RECORDING) {
				//mAudioRecorder.read(mBuffer, 0, mBuffer.length);
				//Log.d(TAG, String.valueOf(mBuffer[0]));
			}
		}
		
	};
	Thread mReadAudioDataThread;
	
	public AudioTest() {
		// check if our preferred buffer is smaller than the min, and if it is, use the min
		mBufferSize = Math.min(AudioRecord.getMinBufferSize(SAMPLE_RATE, CHANNEL_CONFIG, AUDIO_FORMAT), PREFERRED_BUFFER_SIZE);
		
		// initialize the audio recorder using the given audio properties
		mAudioRecorder = new AudioRecord(
				MediaRecorder.AudioSource.MIC,
				SAMPLE_RATE,
				CHANNEL_CONFIG,
				AUDIO_FORMAT,
				mBufferSize);
		
		// allocate the data for the buffer such that sizeof(mBuffer) == mBufferSize
		// (allocate mBufferSize / 2 because we're working with 16 bit shorts)
		mBuffer = new short[mBufferSize / 2];
		
		// initialize the read thread
		mReadAudioDataThread = new Thread(mReadAudioDataRunnable);
	}
	
	public void start() {
		try {
			mAudioRecorder.startRecording();
			//mReadAudioDataThread.start();
		} catch(IllegalStateException e) {
			Log.e(TAG, e.toString());
		}
	}
	
	public void stop() {
		mAudioRecorder.stop();
		try {
			mReadAudioDataThread.join();
		} catch (InterruptedException e) {
			// this should not occur
		}
	}
}
